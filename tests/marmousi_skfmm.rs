// Copyright (c) 2026, Chad Hogan
// All rights reserved.
//
// This source code is licensed under the BSD-3-Clause license found in the
// LICENSE file in the root directory of this source tree.

//! Marmousi model regression test: FIM vs scikit-fmm (first-order).
//!
//! This test loads the Marmousi velocity model (601x1881, dx=5m), runs the FIM
//! solver, and compares the result against a precomputed scikit-fmm reference.
//!
//! The reference file `test_fixtures/marmousi_skfmm_ref.npy` is generated by:
//!     python3 test_fixtures/generate_marmousi_reference.py
//!
//! The test is skipped if either the velocity model or the reference file is
//! missing (both are large data files not checked into version control).

use std::path::Path;
use std::sync::atomic::Ordering;

use eikonal_fim::core::CartesianGrid;
use eikonal_fim::io::{load_npy_slowness, velocity_to_slowness};
use eikonal_fim::scheduler::FimSolver;

const NZ: usize = 601;
const NX: usize = 1881;
const DX: f64 = 5.0;
const SHAPE: [usize; 2] = [NZ, NX];

/// Maximum acceptable mean relative error (far from source) vs scikit-fmm order=1.
const MAX_MEAN_REL_ERROR: f64 = 0.003; // 0.3%

/// Maximum acceptable absolute traveltime error at any grid point.
const MAX_ABS_ERROR: f64 = 0.005; // 5 ms

/// Minimum reference traveltime for relative-error comparison (avoids
/// near-source singularity where the two methods seed differently).
const MIN_TT_FOR_REL: f64 = 0.1; // seconds

#[test]
fn marmousi_vs_skfmm() {
    let project_root = Path::new(env!("CARGO_MANIFEST_DIR"));
    let vel_path = project_root.join("marmousi_vel.npy");
    let ref_path = project_root.join("test_fixtures/marmousi_skfmm_ref.npy");

    // Skip if data files are missing.
    if !vel_path.exists() {
        eprintln!("SKIP: marmousi_vel.npy not found.");
        return;
    }
    if !ref_path.exists() {
        eprintln!(
            "SKIP: test_fixtures/marmousi_skfmm_ref.npy not found. \
             Run: python3 test_fixtures/generate_marmousi_reference.py"
        );
        return;
    }

    // Load velocity and convert to slowness.
    let velocity =
        load_npy_slowness(&vel_path, &[NZ, NX]).expect("failed to load marmousi_vel.npy");
    let slowness = velocity_to_slowness(&velocity).expect("failed to convert velocity to slowness");

    // Build grid and solve.
    let grid = CartesianGrid::<2>::new(SHAPE, DX, slowness).expect("failed to create grid");
    let mut solver = FimSolver::new(grid, 1e-6)
        .expect("failed to create solver")
        .with_tile_size([16, 16])
        .expect("invalid tile size")
        .with_threads(num_cpus());
    solver
        .add_source([0.0, 4700.0])
        .expect("failed to add source");
    solver.solve(None).expect("solver failed");

    // Extract FIM traveltimes.
    let num_nodes = NZ * NX;
    let tt_fim: Vec<f64> = (0..num_nodes)
        .map(|i| f64::from_bits(solver.grid().travel_time_raw()[i].load(Ordering::Relaxed)))
        .collect();

    // Load skfmm reference.
    let tt_ref = load_npy_slowness(&ref_path, &[NZ, NX]).expect("failed to load skfmm reference");

    // --- Absolute error check -----------------------------------------------
    let max_abs = tt_fim
        .iter()
        .zip(tt_ref.iter())
        .map(|(a, b)| (a - b).abs())
        .fold(0.0_f64, f64::max);

    assert!(
        max_abs < MAX_ABS_ERROR,
        "Max absolute error {:.6} s exceeds threshold {:.6} s",
        max_abs,
        MAX_ABS_ERROR,
    );

    // --- Relative error check (far from source) -----------------------------
    let mut sum_rel = 0.0_f64;
    let mut max_rel = 0.0_f64;
    let mut count = 0u64;

    for (fim, &refv) in tt_fim.iter().zip(tt_ref.iter()) {
        if refv > MIN_TT_FOR_REL {
            let rel = (fim - refv).abs() / refv;
            sum_rel += rel;
            if rel > max_rel {
                max_rel = rel;
            }
            count += 1;
        }
    }

    assert!(count > 0, "no points above MIN_TT_FOR_REL threshold");
    let mean_rel = sum_rel / count as f64;

    assert!(
        mean_rel < MAX_MEAN_REL_ERROR,
        "Mean relative error {:.6} exceeds threshold {:.6} (count={})",
        mean_rel,
        MAX_MEAN_REL_ERROR,
        count,
    );

    eprintln!("marmousi_vs_skfmm PASSED:");
    eprintln!("  max  absolute error = {:.6} s", max_abs);
    eprintln!("  mean relative error = {:.6} ({} points)", mean_rel, count);
    eprintln!("  max  relative error = {:.6}", max_rel);
}

fn num_cpus() -> usize {
    std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4)
}
